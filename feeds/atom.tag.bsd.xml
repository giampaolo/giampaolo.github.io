<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Giampaolo Rodola - bsd</title><link href="https://gmpy.dev/" rel="alternate"></link><link href="https://gmpy.dev/feeds/atom.tag.bsd.xml" rel="self"></link><id>https://gmpy.dev/</id><updated>2016-11-06T00:00:00+01:00</updated><subtitle>Python enthusiast, core developer, psutil author</subtitle><entry><title>psutil 5.5.0 is twice as fast</title><link href="https://gmpy.dev/blog/2016/psutil-550-is-twice-as-fast" rel="alternate"></link><published>2016-11-06T00:00:00+01:00</published><updated>2016-11-06T00:00:00+01:00</updated><author><name>Giampaolo Rodola</name></author><id>tag:gmpy.dev,2016-11-06:/blog/2016/psutil-550-is-twice-as-fast</id><summary type="html">&lt;p&gt;OK, this is a big one. Starting from psutil 5.0.0 you can query multiple &lt;cite&gt;Process&lt;/cite&gt; information around twice as fast than with previous versions (see &lt;a class="reference external" href="https://github.com/giampaolo/psutil/issues/799"&gt;original ticket&lt;/a&gt; and &lt;a class="reference external" href="https://psutil.readthedocs.io/en/latest/#psutil.Process.oneshot"&gt;updated doc&lt;/a&gt;). It took me 7 months, 108 commits and a massive refactoring of psutil internals (here is the &lt;a class="reference external" href="https://github.com/giampaolo/psutil/pull/937/files"&gt;big …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;OK, this is a big one. Starting from psutil 5.0.0 you can query multiple &lt;cite&gt;Process&lt;/cite&gt; information around twice as fast than with previous versions (see &lt;a class="reference external" href="https://github.com/giampaolo/psutil/issues/799"&gt;original ticket&lt;/a&gt; and &lt;a class="reference external" href="https://psutil.readthedocs.io/en/latest/#psutil.Process.oneshot"&gt;updated doc&lt;/a&gt;). It took me 7 months, 108 commits and a massive refactoring of psutil internals (here is the &lt;a class="reference external" href="https://github.com/giampaolo/psutil/pull/937/files"&gt;big commit&lt;/a&gt;), and I can safely say this is one of the best improvements and long standing issues which have been addressed in a major psutil release. Here goes.&lt;/p&gt;
&lt;div class="section" id="the-problem"&gt;
&lt;h2&gt;The problem&lt;/h2&gt;
&lt;p&gt;Except for some cases, the way different process information are retrieved varies depending on the OS. Sometimes it requires reading a file in /proc filesystem (Linux), some other times it requires using C (Windows, BSD, OSX, SunOS), but every time it's done differently. Psutil abstracts this complexity by providing a nice high-level interface so that you, say, call &lt;tt class="docutils literal"&gt;Process.name()&lt;/tt&gt; without worrying about what happens behind the curtains or on what OS you're on.&lt;/p&gt;
&lt;p&gt;Internally, it is not rare that multiple process info (e.g. &lt;cite&gt;name()&lt;/cite&gt;, &lt;cite&gt;ppid()&lt;/cite&gt;, &lt;cite&gt;uids()&lt;/cite&gt;, &lt;cite&gt;create_time()&lt;/cite&gt;) may be fetched by using the same routine. For example, on Linux we read &lt;cite&gt;/proc/stat&lt;/cite&gt; to get the process name, terminal, CPU times, creation time, status and parent PID, but only one value is returned and the others are discarded. On Linux the code below reads &lt;cite&gt;/proc/stat&lt;/cite&gt; 6 times:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;psutil&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;psutil&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Process&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cpu_times&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ppid&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;terminal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another example is BSD. In order to get process name, memory, CPU times and other metrics, a single &lt;cite&gt;sysctl()&lt;/cite&gt; call is necessary, but again, because of how psutil used to work so far that same sysctl() call is executed every time (see &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/2fe3f456321ca1605aaa2b71a7193de59d93075c/psutil/_psutil_bsd.c#L242-L258"&gt;here&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/2fe3f456321ca1605aaa2b71a7193de59d93075c/psutil/_psutil_bsd.c#L261-L277"&gt;here&lt;/a&gt;, and so on), one information is returned (say &lt;cite&gt;name()&lt;/cite&gt;) and the rest is discarded. Not anymore.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="do-it-in-one-shot"&gt;
&lt;h2&gt;Do it in one shot&lt;/h2&gt;
&lt;p&gt;It appears clear how the approach described above is not efficient, also considering that applications similar to top, htop, ps or glances usually collect more than one info per-process.
psutil 5.0.0 introduces a new &lt;cite&gt;oneshot()&lt;/cite&gt; context manager. When used, the internal routine is executed once (in the example below on name()) and the other values are cached. The subsequent calls sharing the same internal routine (read &lt;cite&gt;/proc/stat&lt;/cite&gt;, call &lt;cite&gt;sysctl()&lt;/cite&gt; or whatever) will return the cached value.
With psutil 5.0.0 the code above can be rewritten like this, and on Linux it will run 2.4 times faster:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;psutil&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;psutil&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Process&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;oneshot&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cpu_times&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create_time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ppid&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;terminal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="implementation"&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;One great thing about psutil design is its abstraction. It is dived in 3 &amp;quot;layers&amp;quot;. The first layer is represented by the main &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/88ea5e0b2cc15c37fdeb3e38857f6dab6fd87d12/psutil/__init__.py#L340"&gt;Process class&lt;/a&gt; (python), which is what dictates the end-user high-level API. The second layer is the &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/88ea5e0b2cc15c37fdeb3e38857f6dab6fd87d12/psutil/_pslinux.py#L1097"&gt;OS-specific Python module&lt;/a&gt; which is thin wrapper on top of the OS-specific &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/88ea5e0b2cc15c37fdeb3e38857f6dab6fd87d12/psutil/_psutil_linux.c"&gt;C extension module&lt;/a&gt; (third layer). Because this was organized this way (modularly) the refactoring was reasonably smooth. In order to do this I first refactored those C functions collecting multiple info and grouped them in a single function (e.g. see &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/88ea5e0b2cc15c37fdeb3e38857f6dab6fd87d12/psutil/_psutil_bsd.c#L198-L338"&gt;BSD implementation&lt;/a&gt;). Then I wrote a &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/88ea5e0b2cc15c37fdeb3e38857f6dab6fd87d12/psutil/_common.py#L264-L314"&gt;decorator&lt;/a&gt; which enables the cache only when requested (when entering the context manager) and decorated the &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/88ea5e0b2cc15c37fdeb3e38857f6dab6fd87d12/psutil/_psbsd.py#L491"&gt;&amp;quot;grouped functions&amp;quot;&lt;/a&gt; with with it. The whole thing is enabled on request by the highest-level &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/b5582380ac70ca8c180344d9b22aacdff73b1e0b/psutil/__init__.py#L458-L518"&gt;oneshot()&lt;/a&gt; context manager, which is the only thing which is exposed to the end user. Here's the decorator:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;memoize_when_activated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;A memoize decorator which is disabled by default. It can be&lt;/span&gt;
&lt;span class="sd"&gt;    activated and deactivated on request.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="nd"&gt;@functools&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cache_activated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cache&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;KeyError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cache&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;cache_activate&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Activate cache.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cache_activated&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;cache_deactivate&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Deactivate and clear cache.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cache_activated&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;
        &lt;span class="n"&gt;cache&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cache_activated&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;
    &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cache_activate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cache_activate&lt;/span&gt;
    &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cache_deactivate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cache_deactivate&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to measure the various speedups I finally wrote a &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/b5582380ac70ca8c180344d9b22aacdff73b1e0b/scripts/internal/bench_oneshot.py"&gt;benchmark script&lt;/a&gt; (well, &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/b5582380ac70ca8c180344d9b22aacdff73b1e0b/scripts/internal/bench_oneshot_2.py"&gt;two&lt;/a&gt; actually) and kept tuning until I was sure the various changes made psutil actually faster. The benchmark scripts calculate the speedup you can get if you call all the &amp;quot;grouped&amp;quot; methods together (best case scenario).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linux-2-56x-speedup"&gt;
&lt;h2&gt;Linux: +2.56x speedup&lt;/h2&gt;
&lt;p&gt;Linux process is the only pure-python implementation as (almost) all process info are gathered by reading files in the &lt;cite&gt;/proc&lt;/cite&gt; filesystem. &lt;cite&gt;/proc&lt;/cite&gt; files typically contain different information about the process and &lt;cite&gt;/proc/PID/stat&lt;/cite&gt; and &lt;cite&gt;/proc/PID/status&lt;/cite&gt; are the perfect examples. That's why on Linux we aggregate them in 3 groups. The relevant part of the Linux implementation can be seen &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/b5582380ac70ca8c180344d9b22aacdff73b1e0b/psutil/_pslinux.py#L1108-L1153"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="windows-from-1-9x-to-6-5x-speedup"&gt;
&lt;h2&gt;Windows: from +1.9x to +6.5x speedup&lt;/h2&gt;
&lt;p&gt;Windows is an interesting one. In normal circumstances, if we're querying a process owned by our user, we group together only process' &lt;cite&gt;num_threads()&lt;/cite&gt;, &lt;cite&gt;num_ctx_switches()&lt;/cite&gt; and &lt;cite&gt;num_handles()&lt;/cite&gt;, getting a +1.9x speedup if we access those methods in one shot. Windows is particular though, because certain methods use a &lt;a class="reference external" href="https://github.com/giampaolo/psutil/issues/304"&gt;dual implementation&lt;/a&gt;: a &amp;quot;fast method&amp;quot; is attempted first, but if the process is owned by another user it fails with AccessDenied. In that case psutil falls back on using a second &amp;quot;slower&amp;quot; method (see &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/0ccd1373c6e7a189e095df5c436568fb1e8b4d14/psutil/_pswindows.py#L681"&gt;here&lt;/a&gt; for example).
The second method is slower because it &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/0ccd1373c6e7a189e095df5c436568fb1e8b4d14/psutil/arch/windows/process_info.c#L790"&gt;iterates over all PIDs&lt;/a&gt; but differently than &amp;quot;plain&amp;quot; Windows APIs it can be used to &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/0ccd1373c6e7a189e095df5c436568fb1e8b4d14/psutil/_psutil_windows.c#L2789"&gt;get multiple info in one shot&lt;/a&gt;: num threads, context switches, handles, CPU times, create time and IO counters. That is why querying processes owned by other users results in an impressive +6.5 speedup.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="osx-1-92x-speedup"&gt;
&lt;h2&gt;OSX: +1.92x speedup&lt;/h2&gt;
&lt;p&gt;On OSX we can get 2 groups of information. With &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/0ccd1373c6e7a189e095df5c436568fb1e8b4d14/psutil/_psutil_osx.c#L129"&gt;sysctl()&lt;/a&gt; syscall we get process parent PID, uids, gids, terminal, create time, name. With &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/0ccd1373c6e7a189e095df5c436568fb1e8b4d14/psutil/_psutil_osx.c#L183"&gt;proc_info()&lt;/a&gt; syscall we get CPU times (for PIDs owned by another user) memory metrics and ctx switches. Not bad.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bsd-2-18x-speedup"&gt;
&lt;h2&gt;BSD: +2.18x speedup&lt;/h2&gt;
&lt;p&gt;BSD was an interesting one as we gather a tons of process info just by calling &lt;cite&gt;sysctl()&lt;/cite&gt; (see &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/0ccd1373c6e7a189e095df5c436568fb1e8b4d14/psutil/_psutil_bsd.c#L199"&gt;implementation&lt;/a&gt;). In a single shot we get process name, ppid, status, uids, gids, IO counters, CPU and create times, terminal and ctx switches.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sunos-1-37-speedup"&gt;
&lt;h2&gt;SunOS: +1.37 speedup&lt;/h2&gt;
&lt;p&gt;SunOS implementation is similar to Linux implementation in that it reads files in &lt;cite&gt;/proc&lt;/cite&gt; filesystem but differently from Linux this is done in C. Also in this case, we can group different metrics together (see &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/b5582380ac70ca8c180344d9b22aacdff73b1e0b/psutil/_psutil_sunos.c#L83-L142"&gt;here&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/b5582380ac70ca8c180344d9b22aacdff73b1e0b/psutil/_psutil_sunos.c#L171-L189"&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="external-links"&gt;
&lt;h2&gt;External links&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.reddit.com/r/Python/comments/5bhn4q/psutil_500_is_around_twice_as_fast/"&gt;Reddit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="2016"></category><category term="psutil"></category><category term="performance"></category><category term="macos"></category><category term="bsd"></category><category term="sunos"></category><category term="python"></category></entry><entry><title>psutil NetBSD support</title><link href="https://gmpy.dev/blog/2016/psutil-netbsd-support" rel="alternate"></link><published>2016-02-25T00:00:00+01:00</published><updated>2016-02-25T00:00:00+01:00</updated><author><name>Giampaolo Rodola</name></author><id>tag:gmpy.dev,2016-02-25:/blog/2016/psutil-netbsd-support</id><summary type="html">&lt;p&gt;Roughly two months have passed since I last announced &lt;a class="reference external" href="https://github.com/giampaolo/psutil"&gt;psutil&lt;/a&gt; added support for OpenBSD platforms. Today I am happy to announce we also have NetBSD support! This was contributed by &lt;a class="reference external" href="https://github.com/0-wiz-0"&gt;Thomas Klausner&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/ryoon"&gt;Ryo Onodera&lt;/a&gt; and myself in PR &lt;a class="reference external" href="https://github.com/giampaolo/psutil/pull/557"&gt;#570&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="differences-with-freebsd-and-openbsd"&gt;
&lt;h2&gt;Differences with FreeBSD (and OpenBSD)&lt;/h2&gt;
&lt;p&gt;NetBSD implementation has similar limitations as …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;Roughly two months have passed since I last announced &lt;a class="reference external" href="https://github.com/giampaolo/psutil"&gt;psutil&lt;/a&gt; added support for OpenBSD platforms. Today I am happy to announce we also have NetBSD support! This was contributed by &lt;a class="reference external" href="https://github.com/0-wiz-0"&gt;Thomas Klausner&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/ryoon"&gt;Ryo Onodera&lt;/a&gt; and myself in PR &lt;a class="reference external" href="https://github.com/giampaolo/psutil/pull/557"&gt;#570&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="differences-with-freebsd-and-openbsd"&gt;
&lt;h2&gt;Differences with FreeBSD (and OpenBSD)&lt;/h2&gt;
&lt;p&gt;NetBSD implementation has similar limitations as the ones I encountered with OpenBSD. Again, FreeBSD presents itself as the BSD variant with the best support in terms of kernel functionalities.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Process.memory_maps()&lt;/tt&gt; is not implemented. The kernel provides the necessary pieces but I didn't do this yet (hopefully later).&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Process.num_ctx_switches()&lt;/tt&gt;'s involuntary field is always 0. &lt;tt class="docutils literal"&gt;kinfo_proc&lt;/tt&gt; syscall provides this info but it is always set to 0.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Process.cpu_affinity()&lt;/tt&gt; (get and set) is not supported.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;psutil.cpu_count(logical=False)&lt;/tt&gt; always return &lt;tt class="docutils literal"&gt;None&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As for the rest: it is all there. All memory, disk, network and process APIs are fully supported and functioning.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="other-enhancements-available-in-this-psutil-release"&gt;
&lt;h2&gt;Other enhancements available in this psutil release&lt;/h2&gt;
&lt;p&gt;Other than NetBSD support this new release has a couple of interesting enhancements:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/giampaolo/psutil/issues/708"&gt;#708&lt;/a&gt;: [Linux] &lt;tt class="docutils literal"&gt;psutil.net_connections()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Process.connections()&lt;/tt&gt; on Python can be up to 3x faster in case of many connections.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/giampaolo/psutil/issues/718"&gt;#718&lt;/a&gt;: &lt;tt class="docutils literal"&gt;process_iter()&lt;/tt&gt; is now thread safe.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can read the rest in the &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/master/HISTORY.rst"&gt;HISTORY&lt;/a&gt; file, as usual.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="move-to-prague"&gt;
&lt;h2&gt;Move to Prague&lt;/h2&gt;
&lt;p&gt;As a personal note I'd like to add that I'm currently in Prague (Czech Republic) and I'm thinking about moving down here for a while. The city is great and girls are beautiful. ;-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="external-discussions"&gt;
&lt;h2&gt;External discussions&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.reddit.com/r/Python/comments/4131q2/netbsd_support_for_psutil/"&gt;Reddit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://news.ycombinator.com/item?id=10909101"&gt;Hacker news&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="2016"></category><category term="psutil"></category><category term="bsd"></category><category term="python"></category></entry><entry><title>psutil OpenBSD support</title><link href="https://gmpy.dev/blog/2015/psutil-openbsd-support" rel="alternate"></link><published>2015-11-25T00:00:00+01:00</published><updated>2015-11-25T00:00:00+01:00</updated><author><name>Giampaolo Rodola</name></author><id>tag:gmpy.dev,2015-11-25:/blog/2015/psutil-openbsd-support</id><summary type="html">&lt;p&gt;OK, this is a big one: starting from version 3.3.0 (released just now) &lt;a class="reference external" href="https://github.com/giampaolo/psutil"&gt;psutil&lt;/a&gt; will officially support OpenBSD platforms. This was contributed by &lt;a class="reference external" href="https://github.com/landryb"&gt;Landry Breuil&lt;/a&gt; (thanks dude!) and myself in &lt;a class="reference external" href="https://github.com/giampaolo/psutil/pull/615"&gt;PR-615&lt;/a&gt;. The interesting parts of the code changes are this and this.&lt;/p&gt;
&lt;div class="section" id="differences-with-freebsd"&gt;
&lt;h2&gt;Differences with FreeBSD&lt;/h2&gt;
&lt;p&gt;As expected, OpenBSD …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;OK, this is a big one: starting from version 3.3.0 (released just now) &lt;a class="reference external" href="https://github.com/giampaolo/psutil"&gt;psutil&lt;/a&gt; will officially support OpenBSD platforms. This was contributed by &lt;a class="reference external" href="https://github.com/landryb"&gt;Landry Breuil&lt;/a&gt; (thanks dude!) and myself in &lt;a class="reference external" href="https://github.com/giampaolo/psutil/pull/615"&gt;PR-615&lt;/a&gt;. The interesting parts of the code changes are this and this.&lt;/p&gt;
&lt;div class="section" id="differences-with-freebsd"&gt;
&lt;h2&gt;Differences with FreeBSD&lt;/h2&gt;
&lt;p&gt;As expected, OpenBSD implementation is very similar to FreeBSD's (which was already in place), that is why I decided to merge most of it in a single C file (&lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/master/psutil/_psutil_bsd.c"&gt;_psutil_bsd.c&lt;/a&gt;) and use 2 separate C files for when the two implementations differed too much: &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/master/psutil/arch/bsd/freebsd.c"&gt;freebsd.c&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/master/psutil/arch/bsd/freebsd.c"&gt;openbsd.c&lt;/a&gt;. In terms of functionality here's the differences with FreeBSD. Unless specified, these differences are due to the kernel which does not provide the information natively (meaning we can't do anything about it).&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Process.memory_maps()&lt;/tt&gt; is not implemented. The kernel provides the necessary pieces but I didn't do this yet (hopefully later).&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Process.num_ctx_switches()&lt;/tt&gt;'s involuntary field is always 0. &lt;a class="reference external" href="https://github.com/giampaolo/psutil/blob/fc1e59d08c968898c2ede425a621b62ccf44681c/psutil/_psutil_bsd.c#L335"&gt;kinfo_proc&lt;/a&gt; provides this info but it is always set to 0.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Process.cpu_affinity()&lt;/tt&gt; (get and set) is not supported.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Process.exe()&lt;/tt&gt; is determined by inspecting the command line so it may not always be available (return None).&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;psutil.swap_memory()&lt;/tt&gt; sin and sout (swap in and swap out) values are not available and hence are always set to 0.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;psutil.cpu_count(logical=False)&lt;/tt&gt; always return None.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similarly to FreeBSD, also OpenBSD implementation of &lt;cite&gt;Process.open_files()&lt;/cite&gt; is problematic as it is not able to return file paths (FreeBSD can sometimes). Other than these differences the functionalities are all there and pretty much the same, so overall I'm pretty satisfied with the result.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="considerations-about-bsd-platforms"&gt;
&lt;h2&gt;Considerations about BSD platforms&lt;/h2&gt;
&lt;p&gt;psutil has been supporting FreeBSD basically &lt;a class="reference external" href="https://code.google.com/p/psutil/source/detail?r=5f7c3aee0186#"&gt;since the beginning&lt;/a&gt; (year 2009). At the time it made sense to support FreeBSD instead of other BSD variants because it is the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Comparison_of_BSD_operating_systems#Popularity"&gt;most popular&lt;/a&gt;, followed by OpenBSD and NetBSD. Compared to FreeBSD, OpenBSD appears to be more &amp;quot;minimal&amp;quot; both in terms of facilities provided by the kernel and the number of system administration tools available. One thing which I appreciate a lot about FreeBSD is that the source code of all CLI tools installed on the system is available under /usr/bin/src, which was a big help for implementing all psutil APIs. OpenBSD source code is &lt;a class="reference external" href="http://cvsweb.openbsd.org/cgi-bin/cvsweb/"&gt;also available&lt;/a&gt; but it uses CSV and I am not sure it includes the source code for all CLI tools. There are still two more BSD variants for which it may be worth to add support for: NetBSD and DragonflyBSD (in this order). About a year ago some guy provided a &lt;a class="reference external" href="https://github.com/giampaolo/psutil/issues/429"&gt;patch&lt;/a&gt; for adding basic NetBSD support so it is likely that will happen sooner or later.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="other-enhancements-available-in-this-release"&gt;
&lt;h2&gt;Other enhancements available in this release&lt;/h2&gt;
&lt;p&gt;The only other enhancement is &lt;a class="reference external" href="https://github.com/giampaolo/psutil/issues/558"&gt;issue #558&lt;/a&gt;, which allows specifying a different location of /proc filesystem on Linux.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="external-discussions"&gt;
&lt;h2&gt;External discussions&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.reddit.com/r/Python/comments/3u8wm3/openbsd_support_for_psutil_330/"&gt;Reddit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://news.ycombinator.com/item?id=10628726"&gt;Hacker news&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="2015"></category><category term="psutil"></category><category term="bsd"></category><category term="python"></category></entry></feed>