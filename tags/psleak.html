<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--<title>Giampaolo Rodola - psleak</title>-->
    <title>Giampaolo Rodola</title>
    <link rel="stylesheet" href="https://gmpy.dev/theme/css/main.css" />
    <link href="https://gmpy.dev/feeds/atom.all.xml" type="application/atom+xml" rel="alternate" title="Giampaolo Rodola Atom Feed" />
    <link href="https://gmpy.dev/feeds/rss.all.xml" type="application/rss+xml" rel="alternate" title="Giampaolo Rodola RSS Feed" />
    <link rel="icon" type="image/x-icon" href="https://gmpy.dev/favicon.ico">
</head>

<body id="index" class="home">
    <header id="banner" class="body">
        <h1><a href="https://gmpy.dev/about">Giampaolo Rodola <strong>Python enthusiast, core developer, psutil author</strong></a></h1>
        <nav><ul>
            <li><a href="/">Blog</a></li>
            <li><a href="/archives">Archives</a></li>
            <li><a href="/about">About</a></li>
        </ul></nav>
    </header><!-- /#banner -->

<section id="content" class="body">
    <h1 class="entry-title">Blog posts for tags/psleak</h1>

<!-- blog posts -->
        <ol id="posts-list" class="hfeed" start="4">
    <li><article class="hentry">
        <header>
            <h1><a href="https://gmpy.dev/blog/2025/psutil-heap-introspection-apis" rel="bookmark"
                   title="Permalink to Detect memory leaks of C extensions with psutil and psleak">Detect memory leaks of C extensions with psutil and psleak</a></h1>
        </header>
        <div class="entry-content">
<footer class="post-info">
        <a class="published" title="2025-12-23T00:00:00+01:00">
        Created: 23 dic 2025,
        </a>
<!--
        <address class="vcard author">
                By                         <a class="url fn" href="https://gmpy.dev/author/giampaolo-rodola.html">Giampaolo Rodola</a>
        </address>
-->
    <a>Tags:
        <a href="https://gmpy.dev/tags/psutil">psutil</a>,        <a href="https://gmpy.dev/tags/psleak">psleak</a>,        <a href="https://gmpy.dev/tags/python">python</a>,        <a href="https://gmpy.dev/tags/c">c</a>    </a>

<!--
<a href="https://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="grodola">Tweet</a><script type="text/javascript" src="https://platform.twitter.com/widgets.js"></script>
-->
</footer><!-- /.post-info -->            <p>Memory leaks in Python are usually straightforward to diagnose. Just look at
RSS, track Python object counts, follow reference graphs, etc. But leaks inside
<strong>C extension modules</strong> are another story. Traditional memory metrics such as
RSS and VMS fail to reveal them because Python's memory allocator
(<a href="https://docs.python.org/3/c-api/memory.html#the-pymalloc-allocator">pymalloc</a>)
sits above the platform's native heap. If something in an extension calls
<code>malloc()</code> without a corresponding <code>free()</code>, that memory often won't show
up in RSS / VMS. You have a leak, and you don't know.</p>
<p>psutil 7.2.0 introduces two new APIs for <strong>C heap introspection</strong>, designed
specifically to catch these kinds of native leaks. They give you a window
directly into the underlying platform allocator (e.g. glibc's malloc), letting
you track how much memory the C layer actually allocates. If your RSS is flat
but your C heap usage climbs, you now have a way to see it.</p>
<h2>Why native heap introspection matters</h2>
<p>Many Python projects rely on C extensions: psutil, NumPy, pandas, PIL, lxml,
psycopg, PyTorch, custom in-house modules, etc. And even cPython itself, which
implements many of its standard library modules in C. If any of these
components mishandle memory at the C level, you get a leak that doesn't show up in:</p>
<ul>
<li>Python reference counts
  (<a href="https://docs.python.org/dev/library/sys.html#sys.getrefcount">sys.getrefcount</a>)</li>
<li><a href="https://docs.python.org/3/library/tracemalloc.html">tracemalloc module</a></li>
<li>Python's <a href="https://docs.python.org/dev/library/gc.html">gc</a> stats</li>
<li>RSS, VMS or
  <a href="https://gmpy.dev/blog/2016/real-process-memory-and-environ-in-python">USS</a>
  due to allocator caching, especially for small objects. This can happen, for
  example, when you forget to <code>Py_DECREF</code> a Python object.</li>
</ul>
<p>psutil's new functions let you query the allocator (e.g. glibc) directly,
returning low-level metrics from the platform's native heap.</p>
<h2>heap_info(): direct allocator statistics</h2>
<p><code>heap_info()</code> exposes the following metrics:</p>
<ul>
<li><code>heap_used</code>: total number of bytes currently allocated via <code>malloc()</code>
  (small allocations).</li>
<li><code>mmap_used</code>: total number of bytes currently allocated via <code>mmap()</code> or
  via large <code>malloc()</code> allocations.</li>
<li><code>heap_count</code>: (Windows only) number of private heaps created via
  <code>HeapCreate()</code>.</li>
</ul>
<p>Example:</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span><span class="w"> </span><span class="nn">psutil</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">psutil</span><span class="o">.</span><span class="n">heap_info</span><span class="p">()</span>
<span class="n">pheap</span><span class="p">(</span><span class="n">heap_used</span><span class="o">=</span><span class="mi">5177792</span><span class="p">,</span> <span class="n">mmap_used</span><span class="o">=</span><span class="mi">819200</span><span class="p">)</span>
</code></pre></div>

<p>Reference for what contributes to each field:</p>
<table>
<thead>
<tr>
<th>Platform</th>
<th>Allocation type</th>
<th>Field affected</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNIX / Windows</td>
<td>small <code>malloc()</code> â‰¤128 KB without <code>free()</code></td>
<td><code>heap_used</code></td>
</tr>
<tr>
<td>UNIX / Windows</td>
<td>large <code>malloc()</code> &gt;128 KB without <code>free()</code>, or <code>mmap()</code> without <code>munmap()</code> (UNIX)</td>
<td><code>mmap_used</code></td>
</tr>
<tr>
<td>Windows</td>
<td><code>HeapAlloc()</code> without <code>HeapFree()</code></td>
<td><code>heap_used</code></td>
</tr>
<tr>
<td>Windows</td>
<td><code>VirtualAlloc()</code> without <code>VirtualFree()</code></td>
<td><code>mmap_used</code></td>
</tr>
<tr>
<td>Windows</td>
<td><code>HeapCreate()</code> without <code>HeapDestroy()</code></td>
<td><code>heap_count</code></td>
</tr>
</tbody>
</table>
<h2>heap_trim(): returning unused heap memory</h2>
<p><code>heap_trim()</code> provides a cross-platform way to request that the underlying
allocator free any unused memory it's holding in the heap (typically small
<code>malloc()</code> allocations).</p>
<p>In practice, modern allocators rarely comply, so this is not a general-purpose
memory-reduction tool and won't meaningfully shrink RSS in real programs. Its
primary value is in leak detection tools. Calling <code>heap_trim()</code> before taking
measurements helps reduce allocator noise, giving you a cleaner baseline so
that changes in <code>heap_used</code> come from the code you're testing, not from
internal allocator caching or fragmentation.</p>
<h2>Real-world use: finding a C extension leak</h2>
<p>The workflow is simple:</p>
<ol>
<li>Take a baseline snapshot of the heap.</li>
<li>Call the C extension hundreds of times.</li>
<li>Take another snapshot.</li>
<li>Compare.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">psutil</span>

<span class="n">psutil</span><span class="o">.</span><span class="n">heap_trim</span><span class="p">()</span>  <span class="c1"># reduce noise</span>

<span class="n">before</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">heap_info</span><span class="p">()</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">):</span>
    <span class="n">my_cext_function</span><span class="p">()</span>
<span class="n">after</span> <span class="o">=</span> <span class="n">psutil</span><span class="o">.</span><span class="n">heap_info</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;delta heap_used =&quot;</span><span class="p">,</span> <span class="n">after</span><span class="o">.</span><span class="n">heap_used</span> <span class="o">-</span> <span class="n">before</span><span class="o">.</span><span class="n">heap_used</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;delta mmap_used =&quot;</span><span class="p">,</span> <span class="n">after</span><span class="o">.</span><span class="n">mmap_used</span> <span class="o">-</span> <span class="n">before</span><span class="o">.</span><span class="n">mmap_used</span><span class="p">)</span>
</code></pre></div>

<p>If <code>heap_used</code> or <code>mmap_used</code>  values increase consistently, you've found a
native leak.</p>
<p>To reduce false positives, repeat the test multiple times, increasing the
number of calls on each retry. This approach helps distinguish real leaks from
random noise or transient allocations.</p>
<h2>A new tool: psleak</h2>
<p>The strategy described above is exactly what I implemented in a new PyPI
package, which I called <strong><a href="https://github.com/giampaolo/psleak">psleak</a></strong>. It
runs the target function repeatedly, trims the allocator before each run, and
tracks differences across retries. Memory that grows consistently after several
runs is flagged as a leak.</p>
<p>A minimal test suite looks like this:</p>
<div class="highlight"><pre><span></span><code>  <span class="kn">from</span><span class="w"> </span><span class="nn">psleak</span><span class="w"> </span><span class="kn">import</span> <span class="n">MemoryLeakTestCase</span>

  <span class="k">class</span><span class="w"> </span><span class="nc">TestLeaks</span><span class="p">(</span><span class="n">MemoryLeakTestCase</span><span class="p">):</span>
      <span class="k">def</span><span class="w"> </span><span class="nf">test_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">some_c_function</span><span class="p">)</span>
</code></pre></div>

<p>If the function leaks memory, the test will fail with a descriptive exception:</p>
<div class="highlight"><pre><span></span><code>psleak.MemoryLeakError: memory kept increasing after 10 runs
Run # 1: heap=+388160  | uss=+356352  | rss=+327680  | (calls= 200, avg/call=+1940)
Run # 2: heap=+584848  | uss=+614400  | rss=+491520  | (calls= 300, avg/call=+1949)
Run # 3: heap=+778320  | uss=+782336  | rss=+819200  | (calls= 400, avg/call=+1945)
Run # 4: heap=+970512  | uss=+1032192 | rss=+1146880 | (calls= 500, avg/call=+1941)
Run # 5: heap=+1169024 | uss=+1171456 | rss=+1146880 | (calls= 600, avg/call=+1948)
Run # 6: heap=+1357360 | uss=+1413120 | rss=+1310720 | (calls= 700, avg/call=+1939)
Run # 7: heap=+1552336 | uss=+1634304 | rss=+1638400 | (calls= 800, avg/call=+1940)
Run # 8: heap=+1752032 | uss=+1781760 | rss=+1802240 | (calls= 900, avg/call=+1946)
Run # 9: heap=+1945056 | uss=+2031616 | rss=+2129920 | (calls=1000, avg/call=+1945)
Run #10: heap=+2140624 | uss=+2179072 | rss=+2293760 | (calls=1100, avg/call=+1946)
</code></pre></div>

<p>Psleak is now part of the psutil test suite. All psutil APIs are tested (see
<a href="https://github.com/giampaolo/psutil/blob/1a946cfe738045cecf031222cd5078da21946af4/tests/test_memleaks.py">test_memleaks.py</a>),
making it a de facto <strong>regression-testing tool</strong>.</p>
<p>It's worth noting that without inspecting heap metrics, missing calls in the C
code such as <code>Py_CLEAR</code> and <code>Py_DECREF</code> often go unnoticed, because they don't
affect RSS, VMS, and USS. Something I confirmed from experimenting by
commenting them out. Monitoring the heap is therefore essential to reliably
detect memory leaks in Python C extensions.</p>
<h2>Under the hood</h2>
<p>For those interested in seeing how I did this in terms of code:</p>
<ul>
<li><strong><a href="https://github.com/giampaolo/psutil/blob/d40164f1/psutil/arch/linux/heap.c">Linux</a></strong>:
  uses glibc's
  <a href="https://man7.org/linux/man-pages/man3/mallinfo.3.html">mallinfo2()</a> to report
  <code>uordblks</code> (heap allocations) and <code>hblkhd</code> (mmap-backed blocks).</li>
<li><strong><a href="https://github.com/giampaolo/psutil/blob/d40164f1/psutil/arch/windows/heap.c">Windows</a></strong>:
  enumerates heaps and aggregates <code>HeapAlloc</code> / <code>VirtualAlloc</code> usage.</li>
<li><strong><a href="https://github.com/giampaolo/psutil/blob/d40164f1/psutil/arch/osx/heap.c">macOS</a></strong>:
  uses malloc zone statistics.</li>
<li><strong><a href="https://github.com/giampaolo/psutil/blob/d40164f1/psutil/arch/bsd/heap.c">BSD</a></strong>:
  uses jemalloc's arena and stats interfaces.</li>
</ul>
<h2>Summary</h2>
<p>psutil 7.2.0 fills a long-standing observability gap: native-level memory leaks
in C extensions are now visible directly from Python. You now have a simple
method to <strong>test C extensions for leaks</strong>. This turns psutil into not just a
monitoring library, but a practical debugging tool for Python projects that
rely on native C extension modules.</p>
<p>To make leak detection practical, I created
<a href="https://github.com/giampaolo/psleak">psleak</a>, a test-regression framework
designed to integrate into Python unit tests.</p>
<h2>References</h2>
<ul>
<li><strong><a href="https://github.com/giampaolo/psleak">psleak</a></strong>, the new memory leak
  testing framework.</li>
<li><strong><a href="https://github.com/giampaolo/psutil/pull/2692/">psutil PR #2692</a></strong>, the
  implementation.</li>
<li><strong><a href="https://github.com/giampaolo/psutil/issues/1275">psutil issue #1275</a></strong>,
  the original proposal from 8 years earlier.</li>
</ul>
<h2>Discussion</h2>
<ul>
<li><a href="https://www.reddit.com/r/Python/comments/1puqgfg/detect_memory_leaks_of_c_extensions_with_psutil/">Reddit</a></li>
<li><a href="https://news.ycombinator.com/item?id=46376608">Hacker News</a></li>
<li><a href="https://medium.com/@g.rodola/detect-memory-leaks-of-c-extensions-with-psutil-and-psleak-a0521ba6315f">Medium</a></li>
</ul>
        </div>
    </article></li>
 <!-- /blog posts -->
</section>

    <!-- Footer -->
    <section id="extras" class="body">

        <div class="social">
            <h2>Social</h2>
            <ul>
                <li><a href="https://github.com/giampaolo">github</a></li>
                <li><a href="https://www.linkedin.com/in/grodola/">linkedin</a></li>
                <li><a href="https://twitter.com/grodola">twitter</a></li>
            </ul>
        </div><!-- /.social -->

        <div class="feeds">
            <h2>Feeds</h2>
            <ul>
                <li><a href="https://gmpy.dev/feeds/atom.all.xml" type="application/atom+xml" rel="alternate">atom</a></li>
                <li><a href="https://gmpy.dev/feeds/rss.all.xml" type="application/rss+xml" rel="alternate">rss</a></li>
            </ul>
        </div>
    </div>
    </section>
    <!-- /Footer -->

    <footer id="contentinfo" class="body">
        <!--
            <address id="about" class="vcard body">
            Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
            </address>

            <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        -->
    </footer>

    <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-164357405-2', 'auto');
    ga('send', 'pageview');
    </script>
</body>
</html>